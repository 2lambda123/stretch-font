{"version":3,"file":"stretch-font.min.js","sources":["stretch-font.js"],"sourcesContent":["/**\n * The `useStretchFont` function adjusts the font size of HTML elements based on their width and specified minimum and\n * maximum font size values.\n * @param [className=stretch-font] - The class name that identifies the elements that should have their font size\n * stretched. The default value is \"stretch-font\".\n * @param [root] - The `root` parameter is an optional argument that specifies the root element to search for nodes with\n * the class name `className`. If no `root` element is specified, the function will search the entire document for nodes\n * with the class name `className`.\n */\nfunction useStretchFont(root = document, className = 'stretch-font') {\n  const tmplClass = 'stretch-font__tmpl'\n  const store = new Map()\n\n  let resizeObserver = null\n  let tmpl = null\n\n  const body = document.getElementsByTagName('body')[0]\n\n  // Create template for width container\n  if (!body.querySelector('.' + tmplClass)) {\n    tmpl = document.createElement('div')\n    tmpl.classList.add(tmplClass)\n    body.appendChild(tmpl)\n  }\n\n  // Helpers\n  function uniqArrayKeys(array) {\n    return [...new Set(array)]\n  }\n\n  // Mini store\n  function storeSave(node, payload = {}) {\n    if (!payload && !Object.keys(payload).length) return\n    const o = store.get(node)\n    store.set(node, { ...o, ...payload })\n  }\n  function setSize(node) {\n    if (store.get(node)?.size) return\n    const size = getFontSize(node)\n\n    storeSave(node, { size })\n  }\n  function setMin(node) {\n    if (store.get(node)?.min) return\n    let { stretchMin: min } = node.dataset\n\n    storeSave(node, { min: +min })\n  }\n  function setMax(node) {\n    if (!('stretchMax' in node.dataset)) return\n    if (!node.dataset.stretchMax) return\n\n    if (store.get(node)?.max) return\n    let { stretchMax: max } = node.dataset\n\n    storeSave(node, { max: +max })\n  }\n  function setParams(node) {\n    const o = store.get(node)\n\n    const n = document.createElement('span')\n    n.innerHTML = node.innerHTML\n    n.style.fontSize = o.size + 'px'\n    tmpl.appendChild(n)\n\n    let { width, height } = n.getBoundingClientRect()\n    const isStretch = 'stretch' in node.dataset || 'stretchX' in node.dataset || 'stretchY' in node.dataset\n    const freeze = isStretch ? [0, 0] : !o.freeze ? [width, height] : o.freeze\n\n    storeSave(node, { width, height, freeze })\n\n    n.remove()\n  }\n\n  /**\n   * The function returns the font size of a given node element.\n   * @param node - The node parameter is a reference to a DOM element whose font size is to be retrieved.\n   * @returns The function `getFontSize` returns the computed font size of the specified `node` element.\n   */\n  function getFontSize(node) {\n    return +self.getComputedStyle(node, null).getPropertyValue('font-size').slice(0, -2)\n  }\n\n  /**\n   * The function calculates and sets the font size of a given node based on its size, minimum and maximum font size,\n   * width, height, and freeze properties.\n   * @param node - The HTML element node for which the font size needs to be calculated and set.\n   */\n  function formula(node) {\n    const { size, min, max, width, height, freeze } = store.get(node)\n    const [fX, fY] = freeze\n\n    const v = 0.985\n    const x = ((fX || node.getBoundingClientRect().width) / width) * size * v\n    const y = ((fY || node.getBoundingClientRect().height) / height) * size * v\n\n    let fz = x > max || y > max ? max : x < min || y < min ? min : x < y ? x : y\n    if ('stretchX' in node.dataset) fz = x > max ? max : x < min ? min : x\n    if ('stretchY' in node.dataset) fz = y > max ? max : y < min ? min : y\n\n    node.style.fontSize = fz + 'px'\n  }\n\n  /**\n   * The function resizes the font of entries using requestAnimationFrame.\n   * @param entries - The `entries` parameter is an array of `IntersectionObserverEntry` objects. These objects represent\n   * the elements that are being observed by an `IntersectionObserver` instance and contain information about their\n   * intersection with the viewport. In this case, the `entries` array is being passed to a function called `entries\n   */\n  function entriesResize(entries) {\n    self.requestAnimationFrame(() => entries.forEach(({ target }) => formula(target)))\n  }\n\n  /**\n   * The function finds all nodes with a specific class name within a given target element.\n   * @param target - The target parameter is a DOM element that is being searched for nodes with a specific class name.\n   * @returns The function `findNodes` returns an array of DOM elements that have a class name matching the `className`\n   * parameter. If the `target` parameter itself has the matching class name, it will be the only element in the returned\n   * array. If there are no matching elements, an empty array will be returned.\n   */\n  function getNodes(target) {\n    return target.querySelectorAll('.' + className) || []\n  }\n\n  /**\n   * The function \"rebuild\" performs various operations on a given node element, including setting its minimum and maximum\n   * size, calculating its size and width, applying a formula, and observing its resizing.\n   * @param node - The node parameter is a reference to a DOM element that needs to be rebuilt. The function rebuild() is\n   * responsible for setting various properties and attributes of the node, such as its minimum and maximum size, its size,\n   * and its width. It also calls a formula() function and sets up a resizeObserver\n   */\n  function rebuild(node) {\n    if ('stretchMin' in node.dataset) setMin(node)\n    if ('stretchMax' in node.dataset) setMax(node)\n    setSize(node)\n    setParams(node)\n\n    formula(node)\n    resizeObserver.observe(node)\n  }\n\n  self.addEventListener('DOMContentLoaded', () => {\n    // Watch resize\n    resizeObserver = new ResizeObserver(entriesResize)\n\n    // init\n    getNodes(root).forEach(rebuild)\n\n    // Watch mutation\n    new MutationObserver(entries => {\n      const manipulate = entries\n        .filter(({ type, target }) => type === 'childList' && !target.classList?.contains(tmplClass))\n        .map(({ target }) => {\n          if (target.classList?.contains(className)) return target\n          return [...Array.from(getNodes(target)).filter(node => !store.has(node))]\n        })\n        .flat()\n\n      const mutation = entries\n        .filter(({ type, target: { parentNode } }) => {\n          if (type !== 'characterData') return\n          if (!parentNode.classList?.contains(className)) return\n          if (!store.has(parentNode)) return\n          const s = store.get(parentNode)\n          const r = parentNode.getBoundingClientRect()\n          return s.width !== r.width || s.height !== r.height\n        })\n        .map(({ target }) => target.parentNode)\n\n      uniqArrayKeys([...mutation, ...manipulate]).forEach(rebuild)\n    }).observe(root, { characterData: true, childList: true, subtree: true })\n  })\n}\n\nexport default useStretchFont\n"],"names":["root","arguments","length","undefined","document","className","tmplClass","store","Map","resizeObserver","tmpl","body","getElementsByTagName","storeSave","node","payload","Object","keys","o","get","set","_objectSpread","setSize","_store$get","size","self","getComputedStyle","getPropertyValue","slice","getFontSize","formula","_store$get4","min","max","width","height","_freeze","_slicedToArray","freeze","fX","fY","x","getBoundingClientRect","y","fz","dataset","style","fontSize","entriesResize","entries","requestAnimationFrame","forEach","_ref","target","getNodes","querySelectorAll","rebuild","_store$get2","stretchMin","setMin","_store$get3","stretchMax","setMax","n","createElement","innerHTML","appendChild","_n$getBoundingClientR","remove","setParams","observe","querySelector","classList","add","addEventListener","ResizeObserver","MutationObserver","array","manipulate","filter","_ref2","_target$classList","type","contains","map","_ref3","_target$classList2","_toConsumableArray","Array","from","has","flat","mutation","_ref4","_parentNode$classList","parentNode","s","r","_ref5","concat","Set","characterData","childList","subtree"],"mappings":"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"}